Algorithm: LCF
Input: string x, string y
Output: list of all statrting possitions in string x of longest pattern x in text y and length of matchion pattern
M <- SuffixAutomaton(x)
best_length <- 0
best_states <- Empty_list
cur_length <- 0
state <- 0
# walk y
for letter <- 0..(|y| - 1) do
 	if letter not in M[next[state]] then	# check for transitions
		cur_length <- cur_length +1
		state <- M[next[state[letter]]]
	else
		repeat
			cur_length <- cur_length +1	# walk suffix links
			state <- M[suffix_link[state]]
		until state = 0 or letter in M[next[state]]

		if letter in M[next[state]] then
			cur_length <- cur_length +1
			state <- M[next[state[letter]]]
		else	
			cur_length <- 0		# reset root
	
	if cur_length > best_length then	# update best_lenght
		best_length <- cur_length
		best_states <- Empty_list
		best_states[0] <- state
	else
		if cur_length > best_length then
			append state to best_states

    if best_len == 0:	# no common substring, return ([], 0)
        return (empty list, 0)

    hits = empty list
    L = best_len

    for each state s in best_states:
        t_in  = M[tin[s]]
        t_out = M[tout[s]]

        for i from 0 to |x| - 1:	# scan all end positions i in x
            st = M[state_at_pos[i]]

            if t_in ≤ M.tin[st] ≤ t_out:	# subtree of s?
                start_pos = i - L + 1   # substring x[start_pos .. i] has length L
                append start_pos to hits
return hits, L
